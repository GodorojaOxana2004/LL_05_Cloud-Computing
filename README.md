# Лабораторная работа №5. Облачные базы данных. Amazon RDS, DynamoDB

## Цель работы

Целью работы является ознакомление с сервисами Amazon RDS (Relational Database Service) и Amazon DynamoDB, а также получение навыков:

- Создания и настройки экземпляров реляционных баз данных в облаке AWS с использованием Amazon RDS.
- Понимания концепции Read Replicas и применения их для повышения производительности и отказоустойчивости баз данных.
- Подключения к базе данных Amazon RDS с виртуальной машины EC2 и выполнения базовых операций с данными (создание, чтение, обновление, удаление записей - CRUD).
- (_Дополнительно_) Ознакомления с сервисом Amazon DynamoDB и освоения работы с хранением данных в NoSQL-формате.

## Выполнение работы

### Шаг 1. Подготовка среды (VPC/подсети/SG)

1. Создала VPC (`project-vpc`) с _двумя публичными_ и _двумя приватными_ подсетями в разных зонах доступности (AZ). В данной подсети были развернуты базы данных и приложение.
   1. Для создания подсетей воспользовалась _мастером создания VPC_ (Create VPC -> VPC and more) в консоли AWS.
   ![img](/images/img_1.png)
2. Создала группу безопасности (`web-security-group`) для приложения, разрешающую следующий трафик:
   - Входящий: HTTP (порт 80) от любого источника;
   - Входящий: SSH (порт 22) от любого источника (для учебных целей);
   ![img](/images/img_2.png)
3. Создала группу безопасности (`db-mysql-security-group`) для базы данных, разрешающую следующий трафик:
   - Входящий: MySQL/Aurora (порт 3306) от `web-security-group` (т.е. только ресурсы, принадлежащие этой группе безопасности, смогут подключаться к базе данных);
   ![img](/images/img_3.png)
4. Изменила `web-security-group`, добавив правило для исходящего трафика:
   - Исходящий: MySQL/Aurora (порт 3306) к `db-mysql-security-group` (т.е. приложение сможет инициализировать соединение с базой данных).
   ![img](/images/img_4.png)

### Шаг 2. Развертывание Amazon RDS

1. Перешла в консоль Amazon Aurora and RDS.
2. Создала `Subnet Group` для базы данных.

   > **Что такое Subnet Group? И зачем необходимо создавать Subnet Group для базы данных?**

   **Ответ:** Subnet Group — это группа подсетей в VPC, которая определяет, в каких подсетях AWS может развернуть экземпляры базы данных RDS. Это необходимо для обеспечения высокой доступности (Multi-AZ) и правильной сетевой изоляции базы данных в приватных подсетях.

   - Название: `project-rds-subnet-group`
   - Выбрала созданный ранее VPC и добавила 2 приватные подсети из 2 разных AZ.
   ![img](/images/img_5.png)
3. Создала экземпляр базы данных Amazon RDS (Databases -> Create database).
   
4. В разделе `Choose a database creation method` выбрала `Standard Create`. Это позволило настроить все параметры базы данных вручную, что полезно для учебных целей.
5. Выбрала следующие параметры базы данных:
   - Engine type: `MySQL`
   - Version: `MySQL 8.0.42` (или последнюю доступную версию)
   - Templater: `Free tier` (так как это учебная среда)
   - Availability and durability: `Single-AZ DB instance deployment`
   - DB instance identifier (название сервера базы данных): `project-rds-mysql-prod`
   - Master username: `admin` (имя пользователя администратора базы данных)
   - _Master password_: `impact7723`
   - DB instance class: `Burstable classes (includes t classes)`, `db.t3.micro` (подходит для учебных целей)
   - Storage:
     - Storage type: `General Purpose SSD (gp3)`
     - Allocated storage: `20 GB` (минимально доступный размер для учебных целей)
     - Enable storage autoscaling: `Checked` (это позволит базе данных автоматически увеличивать размер хранилища при необходимости)
     - Maximum storage threshold: `100 GB`
   - Connectivity (подключение)
     - Выбрала `Don't connect to an EC2 compute resource`
     - Virtual private cloud (VPC): выбрала созданный ранее VPC
     - DB subnet group: выбрала созданную ранее Subnet Group `project-rds-subnet-group`
     - Public access: `No` (база данных не будет доступна из интернета)
     - Existing VPC security groups: выбрала созданную ранее группу безопасности `db-mysql-security-group`
     - Availability zone: `No preference` (AWS выберет зону автоматически)
   - Additional configuration
     - Initial database name: `project_db` (название базы данных, которая будет создана при инициализации)
     - Backup (Enable automated backup): поставила галочку (_для создания read replica необходимы бэкапы_)
     - Backup (Enable encryption): сняла галочку (_для учебных целей шифрование не требуется_)
     - Maintanance (Enable auto minor version upgrade): сняла галочку (_для учебных целей автоматическое обновление не требуется_)
   - Нажала `Create database` для создания базы данных.
  ![img](/images/img_6.png)
6. Дождалась завершения создания базы данных (статус изменился на `Available`).
   
7. Скопировала `Endpoint` базы данных (он понадобился для подключения).
```text
project-rds-mysql-prod.c5cy66m0io39.eu-central-1.rds.amazonaws.com
```

### Шаг 3. Создание виртуальной машины для подключения к базе данных

Создала виртуальную машину EC2 в публичной подсети VPC, чтобы использовать её для подключения к базе данных RDS.

Для виртуальной машины использовала группу безопасности `web-security-group`, созданную ранее.

При инициализации виртуальной машины установила MySQL клиент, чтобы упростить подключение к базе данных RDS.

```bash
#!/bin/bash
dnf update -y
dnf install -y mariadb105 # Установка MariaDB/MySQL клиента (подходит и для MySQL и для MariaDB)
```
![img](/images/img_7.png)

### Шаг 4. Подключение к базе данных и выполнение базовых операций

1. Подключилась к виртуальной машине EC2 по SSH.
2. Подключилась к базе данных RDS с помощью MySQL клиента:
   ```bash
   mysql -h <RDS_ENDPOINT> -u admin -p
   ```
   где, `<RDS_ENDPOINT>` - это скопированный ранее endpoint базы данных RDS.
   ```
   mysql -h project-rds-mysql-prod.c5cy66m0io39.eu-central-1.rds.amazonaws.com -u admin -p
   ```
3. Ввела пароль администратора базы данных, который указала при создании базы данных.
4. После успешного подключения выбрала базу данных:
   ```sql
   USE project_db;
   ```
5. Создала две таблицы. Между таблицами создала связь 1 ко многим (one-to-many).
   - Например: таблица `categories (id, name)` и таблица `todos (id, title, category_id, status)`, где `category_id` - внешний ключ, ссылающийся на `categories.id`.
6. Вставила несколько записей в каждую таблицу (минимум по 3 записи в каждую таблицу).
7. Выполнила несколько запросов на выборку данных, включая JOIN между таблицами.

![img](/images/img_8.png)
![img](/images/img_9.png)

### Шаг 5. Создание Read Replica

1. Выбрала базу данных RDS в консоли AWS.
2. Нажала на кнопку `Actions` и выбрала `Create read replica`.
3. Указала следующие параметры для Read Replica:
   - DB instance identifier: `project-rds-mysql-read-replica`
   - Instance class: `db.t3.micro`
   - Storage type: `General Purpose SSD (gp3)`
   - Monitoring
     - Enable Enhanced monitoring: _сняла галочку_ (для учебных целей не требуется)
   - Public access: `No`
   - VPC security groups: выбрала ту же группу безопасности `db-mysql-security-group`
4. Дождалась, пока реплика перешла в статус `Available`. У неё появился свой `endpoint` (_только для чтения_).
```
project-rds-mysql-read-replica.c5cy66m0io39.eu-central-1.rds.amazonaws.com

mysql -h project-rds-mysql-read-replica.c5cy66m0io39.eu-central-1.rds.amazonaws.com -u admin -p
```
5. Подключилась к Read Replica с виртуальной машины EC2 и выполнила запросы на чтение данных (SELECT) из таблиц, созданных на основном экземпляре базы данных.
   ![img](/images/img_13.png)

   > **Какие данные вы видите? Объясните почему.**

   **Ответ:** Вижу все данные, которые были добавлены в основную базу данных. Это происходит потому, что Read Replica автоматически реплицирует (копирует) данные из основного экземпляра (master) в режиме реального времени.

6. Попробовала выполнить запрос на запись (INSERT/UPDATE) на реплике.
   ![img](/images/img_12.png)

   > **Получилось ли выполнить запись на Read Replica? Почему?**

   **Ответ:** Нет, запись на Read Replica не получилась. Read Replica работает только в режиме чтения (read-only). Она предназначена для распределения нагрузки чтения и не принимает операции записи, чтобы избежать конфликтов данных и сохранить целостность репликации.

7. Перешла на основной экземпляр базы данных и добавила новую запись в одну из таблиц.

8. Вернулась к подключению к Read Replica и выполнила запрос на чтение.

   ![img](/images/img_14.png)

   > **Отобразилась ли новая запись на реплике? Объясните почему.**

   **Ответ:** Да, новая запись отобразилась на реплике. Это произошло благодаря асинхронной репликации — изменения из основной базы данных автоматически передаются на Read Replica с небольшой задержкой (replication lag).

9. > **Объясните, зачем нужны Read Replicas и в каких сценариях их использование будет полезным.**

   **Ответ:** Read Replicas используются для:
   - **Масштабирования чтения** — распределение запросов SELECT между несколькими репликами снижает нагрузку на основную базу данных.
   - **Повышения производительности** — пользователи могут читать данные из географически ближайшей реплики.
   - **Аналитики и отчетности** — тяжелые запросы для отчетов выполняются на реплике, не мешая работе основной БД.
   - **Повышения доступности** — в случае сбоя основной БД реплику можно повысить до основной (promote).

### Шаг 6. Подключение приложения к базе данных

#### Шаг 6a. Развертывание CRUD приложения

1. _Разработала и развернула_ простое веб-приложение на виртуальной машине Amazon EC2, которое подключается к базе данных Amazon RDS и выполняет базовые операции с данными (создание, чтение, обновление, удаление записей - CRUD).
```bash
# установка Apache и PHP
sudo dnf install -y httpd php php-mysqlnd

# запуск веб-сервера и автозапуск при старте
sudo systemctl start httpd
sudo systemctl enable httpd
```
![img](/images/img_10.png)

2. Настроила приложение таким образом, чтобы для операций записи и изменения данных использовался основной экземпляр (`master instance`), а для операций чтения - реплика для чтения (`read replica`).
![img](/images/img_11.png)
![img](/images/img_15.png)
![img](/images/img_16.png)
![img](/images/img_17.png)
![img](/images/img_18.png)

### Шаг 7. Дополнительное задание. Использование DynamoDB

1. Спроектировала таблицу в Amazon DynamoDB для хранения данных приложения (задачи - `Todos`).

**Структура таблицы:**

| Поле | Тип | Примечание |
|------|-----|------------|
| todo_id | String | Primary Key (уникальный идентификатор задачи) |
| title | String | Название задачи |
| category | String | Категория задачи |
| status | String | Статус задачи (pending, completed) |
| created_at | String | Дата и время создания задачи |

2. Создала таблицу в сервисе Amazon DynamoDB. Выбрала Primary Key и обосновала выбор.

**Primary Key:** `todo_id` — уникальный идентификатор каждой задачи.
**Sort Key:** не использовала, т.к. все задачи уникальны по `todo_id`. Если бы нужно было хранить задачи по категориям и сортировать их, тогда `category` можно было бы сделать Sort Key.

   > **Какие преимущества и недостатки использования DynamoDB по сравнению с реляционной базой данных Amazon RDS в вашем случае?**

   **Ответ:** 
   
   **Преимущества DynamoDB:**
   - Высокая производительность при больших объемах данных
   - Автоматическое масштабирование
   - Низкая задержка доступа к данным
   - Подходит для простых структур данных без сложных связей
   
   **Недостатки DynamoDB:**
   - Отсутствие поддержки JOIN операций
   - Сложность реализации связей между таблицами
   - Ограниченные возможности для сложных запросов
   - Нет поддержки транзакций в классическом понимании (хотя есть транзакции DynamoDB)

![img](/images/img_19.png)

3. Добавила несколько записей в таблицу с помощью консоли AWS или утилиты AWS CLI, чтобы проверить корректность работы таблицы.

Перед этим добавила роль `dynamodb full access`.

![img](/images/img_20.png)
![img](/images/img_21.png)

4. Изменила приложение (из Шага 6), добавив функциональность для взаимодействия с таблицей DynamoDB:

   - Реализовала операции создания, чтения, обновления и удаления записей в таблице;
   - Убедилась, что приложение корректно выполняет все основные операции с данными (CRUD) через DynamoDB;
   - Использовала AWS SDK для PHP для упрощения интеграции с DynamoDB.

   > **Какие сложности вы столкнулись при проектировании данных для DynamoDB по сравнению с реляционной моделью данных в Amazon RDS?**

   **Ответ:** Основные сложности включают:
   - Отсутствие поддержки связей между таблицами (foreign keys) — пришлось денормализовать данные
   - Необходимость заранее продумывать паттерны доступа к данным
   - Отсутствие JOIN — для получения связанных данных требуется несколько запросов
   - Сложность реализации сложных запросов с фильтрацией и сортировкой
   - Необходимость использовать другую ментальную модель при проектировании схемы данных

![img](/images/img_22.png)
![img](/images/img_23.png)
![img](/images/img_24.png)
![img](/images/img_25.png)

5. > **Продумайте ситуацию, в которой целесообразно использовать обе базы данных - Amazon RDS и Amazon DynamoDB - в одном приложении. Опишите возможный сценарий, в котором каждая из баз выполняет свою роль. Объясните, почему совместное использование этих технологий будет оправдано и какие преимущества оно даёт по сравнению с использованием только одной из них.**

   **Ответ:** 
   
   **Сценарий использования обеих баз данных:**
   
   Интернет-магазин с системой аналитики и рекомендаций:
   
   **Amazon RDS (MySQL):**
   - Хранение каталога товаров со сложными связями (категории, производители, характеристики)
   - Управление заказами с транзакциями
   - Хранение информации о пользователях и их профилях
   - Финансовые операции, требующие ACID-транзакций
   
   **Amazon DynamoDB:**
   - Хранение истории просмотров пользователей (высокая скорость записи)
   - Корзина покупок (требуется быстрый доступ и высокая доступность)
   - Сессии пользователей
   - Кэширование популярных товаров
   - Логи событий и метрики в реальном времени
   
   **Преимущества гибридного подхода:**
   - Оптимизация под разные типы нагрузки (транзакционные vs. большой объем простых операций)
   - Экономия средств — использование DynamoDB для простых данных с высокой нагрузкой дешевле масштабирования RDS
   - Повышение производительности — каждая БД работает с тем типом данных, для которого оптимизирована
   - Лучшая масштабируемость — DynamoDB автоматически масштабируется для высоконагруженных операций
   - Гибкость архитектуры — возможность выбирать оптимальное решение для каждой задачи